<!DOCTYPE html>
<html lang="en">

<head>
	<title>Add a 3D model with three.js</title>
	<meta property="og:description" content="Use a custom style layer with three.js to add a 3D model to the map." />
	<meta charset='utf-8'>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
	<div id="map"></div>
	<script type="importmap">
		{
			"imports": {
				"three": "../build/three.module.js",
				"three/addons/": "./jsm/"
			}
		}
	</script>

	<script type="module">
		import * as THREE from 'three';
		import * as maplibregl from 'maplibre-gl';
		import Stats from 'three/addons/libs/stats.module.js';
		import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { datas } from './data.js';
		import SunCalc from 'suncalc'



		let inten = 3;
		const map = new maplibregl.Map({
			container: 'map',
			style: 'https://api.maptiler.com/maps/basic/style.json?key=0LV4DUQC2Ud6fTkmgGJf',
			// style: style,
			// style: "https://basemaps.cartocdn.com/gl/positron-gl-style/style.json",
			zoom: 18,
			center: [105.82713626435122, 21.031704033872295],
			pitch: 60,
			antialias: true // create the gl context with MSAA antialiasing, so custom layers are antialiased
		});
		let dataLayers = [];

		const findMissingElements = (array1, array2, key) => {
			const keysSet = new Set(array2.map(item => item[key]));
			const missingElements = array1.filter(item => !keysSet.has(item[key]));
			return missingElements;
		}

		const getLayerInView = (ne, sw) => {
			const ne_lat = ne.lat;
			const ne_lng = sw.lng;
			const sw_lat = sw.lat;
			const sw_lng = ne.lng;
			let dataLayersInView = datas.reduce((oldData, item) => {
				let item_lng = item.coordinates[0];
				let item_lat = item.coordinates[1];

				if (ne_lng > sw_lng) {
					if (item_lng > sw_lng && item_lng < ne_lng && item_lat > sw_lat && item_lat < ne_lat) {
						oldData.push(item);
					}
				} else {
					if (item_lng < sw_lng && item_lng > ne_lng && item_lat > sw_lat && item_lat < ne_lat) {
						oldData.push(item);
					}
				}
				return oldData;
			}, [])

			dataLayersInView = findMissingElements(dataLayersInView, dataLayers, 'id');
			dataLayers.push(...dataLayersInView);
			return dataLayersInView;
		}

		//use the MapLibre GL JS map canvas for three.js
		let renderer = new THREE.WebGLRenderer({
			canvas: map.getCanvas(),
			antialias: true
		});

		const addLayer = (object) => {
			let scene, camera, stats;
			let model, skeleton, mixer, clock, animations;
			console.log(object.id)
			camera = new THREE.Camera();
			scene = new THREE.Scene();
			// parameters to ensure the model is georeferenced correctly on the map
			const modelOrigin = object.coordinates;
			const modelAltitude = 0;
			const modelRotate = [Math.PI / 2, 0, 0];
			const modelAsMercatorCoordinate = maplibregl.MercatorCoordinate.fromLngLat(
				modelOrigin,
				modelAltitude
			);

			// transformation parameters to position, rotate and scale the 3D model onto the map
			const modelTransform = {
				translateX: modelAsMercatorCoordinate.x,
				translateY: modelAsMercatorCoordinate.y,
				translateZ: modelAsMercatorCoordinate.z,
				rotateX: modelRotate[0],
				rotateY: modelRotate[1],
				rotateZ: modelRotate[2],
				/* Since our 3D model is in real world meters, a scale transform needs to be
				* applied since the CustomLayerInterface expects units in MercatorCoordinates.
				*/
				scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits()
			};

			const ambientLight = new THREE.AmbientLight(0xffffff, inten);
			const dirLight = new THREE.DirectionalLight(0xffffff, inten);
			let d = 2048;
			let r = 2;
			let mapSize = 8192;
			dirLight.position.set(0, 700, 100);
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = mapSize;
			dirLight.shadow.mapSize.height = mapSize;
			dirLight.shadow.camera.top = dirLight.shadow.camera.right = d;
			dirLight.shadow.camera.bottom = dirLight.shadow.camera.left = -d;
			dirLight.shadow.mapSize.width = dirLight.shadow.mapSize.height = 1024
			dirLight.shadow.camera.near = 1;
			dirLight.shadow.camera.far = 400000;
			dirLight.shadow.camera.visible = true; 
			scene.add(dirLight, ambientLight);
			// configuration of the custom layer for a 3D model per the CustomLayerInterface
			const customLayer = {
				id: object.id,
				type: 'custom',
				renderingMode: '3d',
				onAdd(map, gl) {
					// use the three.js GLTF loader to add the 3D model to the three.js scene
					const loader = new GLTFLoader();
					loader.load(
						object.scenegraph,
						(gltf) => {
							let glsence = gltf.scene;
							glsence.traverse(function (model) {
								if (model.isMesh) {
									model.castShadow = true;
								}
							});
							glsence.castShadow = true;
							glsence.scale.set(3.64, 3.3, 3.3);
							glsence.rotation.set(0, 1.376, 0);
							scene.add(glsence);
							const s = new THREE.Box3().setFromObject(glsence).getSize(new THREE.Vector3(0, 0, 0));
							const sizes = [s.x, s.y, s.z];
							const planeSize = Math.max(...sizes) * 10;
							const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
							const planeMat = new THREE.ShadowMaterial();
							planeMat.opacity = 0.5;
							let plane = new THREE.Mesh(planeGeo, planeMat);
							plane.rotateX(-Math.PI / 2);
							plane.receiveShadow = true;
							scene.add(plane);
						}
					);
					renderer.autoClear = false;
					// renderer.shadowMap.autoUpdate = false;
					renderer.shadowMap.type = THREE.PCFSoftShadowMap;
					renderer.shadowMap.enabled = true;
					renderer.shadowMap.needsUpdate = true;
				},

				render(gl, matrix) {
					function animateSun() {
						const date = new Date(); // Current date and time
						date.setHours(date.getHours());
						const latitude = 21.0285; // Latitude of Hanoi
						const longitude = 105.8542; // Longitude of Hanoi
						const sunPosition = SunCalc.getPosition(date, latitude, longitude);
						// Convert Sun's Azimuth and Altitude to Three.js coordinates
						const azimuth = -sunPosition.azimuth + Math.PI; // Inverse azimuth for Three.js
						const altitude = sunPosition.altitude;
						// Convert azimuth and altitude to directional light position
						const lightDistance = 1024; // Distance of light from the scene origin
						const lightPosition = new THREE.Vector3(
							lightDistance * Math.cos(altitude) * Math.sin(azimuth),
							lightDistance * Math.sin(altitude),
							lightDistance * Math.cos(altitude) * Math.cos(azimuth)
						);
						// Normalize altitude to be between 0 and 1 (assuming sun is above horizon)
						const normalizedAltitude = Math.max(0, Math.min(1, altitude / (Math.PI / 2)));
						// Set light intensity based on normalized altitude
						const minIntensity = 0.1                                  ; // Minimum intensity during nighttime
						const maxIntensity = 5; // Maximum intensity during daytime
						const lightIntensity = minIntensity + (maxIntensity - minIntensity) * normalizedAltitude ;                           
						// console.log("lightIntensity",lightIntensity)
						// const lightIntensity = 1.5
						if (lightIntensity <= 1 && lightLevel == 2) {
							map.setStyle('https://api.maptiler.com/maps/f3b4e6d4-f9ff-48ab-b2b3-8fdc83e21290/style.json?key=lekGUCzmcgURiaChlHJb', { diff: false }),
							lightLevel = 1;
						}
						if (lightIntensity > 1 && lightLevel == 1 ) {
							map.setStyle('https://api.maptiler.com/maps/basic/style.json?key=0LV4DUQC2Ud6fTkmgGJf', { diff: false }),
							lightLevel = 2
						}
						// Set up directional light
						dirLight.position.copy(lightPosition);
						dirLight.intensity = lightIntensity;
						ambientLight.intensity = lightIntensity / 2 ;
						// requestAnimationFrame(animateSun);

					}

					const rotationX = new THREE.Matrix4().makeRotationAxis(
						new THREE.Vector3(1, 0, 0),
						modelTransform.rotateX
					);
					const rotationY = new THREE.Matrix4().makeRotationAxis(
						new THREE.Vector3(0, 1, 0),
						modelTransform.rotateY
					);
					const rotationZ = new THREE.Matrix4().makeRotationAxis(
						new THREE.Vector3(0, 0, 1),
						modelTransform.rotateZ
					);

					const m = new THREE.Matrix4().fromArray(matrix);
					const l = new THREE.Matrix4()
						.makeTranslation(
							modelTransform.translateX,
							modelTransform.translateY,
							modelTransform.translateZ
						)
						.scale(
							new THREE.Vector3(
								modelTransform.scale,
								-modelTransform.scale,
								modelTransform.scale
							)
						)
						.multiply(rotationX)
						.multiply(rotationY)
						.multiply(rotationZ);

					camera.projectionMatrix = m.multiply(l);
					renderer.resetState();
					renderer.render(scene, camera);
					animateSun();
					map.triggerRepaint();
				}
			};
			map.addLayer(customLayer);
		}
		let lightLevel = 2;
		map.on('load', function () {
			const initialViewport = getWebViewport();
			const dataLayersInView = getLayerInView(initialViewport._ne, initialViewport._sw);
			dataLayersInView.forEach((item) => addLayer(item));
		})

		map.on('style.load', function () {
			console.log("tyle.load")
			dataLayers = [];
			const initialViewport = getWebViewport();
			const dataLayersInView = getLayerInView(initialViewport._ne, initialViewport._sw);
			dataLayersInView.forEach((item) => addLayer(item));
		});

		map.on('click', (e) => {
			// const coordinates = e.features[0].geometry.coordinates.slice();
			console.log('coordinates', e)
		});

		// Function to get the web viewport with center coordinates
		function getWebViewport() {
			var bounds = map.getBounds();
			return bounds;
		}

		// Event listener for the 'dragend' event
		map.on('dragend', function () {
			const viewport = getWebViewport();
			const dataLayersInView = getLayerInView(viewport._ne, viewport._sw);
			console.log("dataLayersInView", dataLayersInView)
			if (dataLayersInView.length > 0) {
				dataLayersInView.forEach((item) => addLayer(item));
			}
		});


	</script>
</body>

</html>
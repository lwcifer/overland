<!DOCTYPE html>
<html lang="en">

<head>
	<title>Add a 3D model with three.js</title>
	<meta property="og:description" content="Use a custom style layer with three.js to add a 3D model to the map." />
	<meta charset='utf-8'>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>

<body>
	<div id="control">
		<div id="change-day-night-btn">Day</div>
	</div>
	<div id="map"></div>
	<script type="importmap">
		{
			"imports": {
				"three": "../build/three.module.js",
				"three/addons/": "./jsm/"
			}
		}
	</script>

	<script type="module">
		import * as THREE from 'three';
		import * as maplibregl from 'maplibre-gl';
		import Stats from 'three/addons/libs/stats.module.js';
		import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import { datas } from './data.js';
		import SunCalc from 'suncalc'



		let inten = 3;
		const map = new maplibregl.Map({
			container: 'map',
			style: 'https://api.maptiler.com/maps/basic/style.json?key=0LV4DUQC2Ud6fTkmgGJf',
			// style: style,
			// style: "https://basemaps.cartocdn.com/gl/positron-gl-style/style.json",
			zoom: 18,
			center: [105.83524935692617, 21.0369236457444],
			pitch: 60,


			antialias: true // create the gl context with MSAA antialiasing, so custom layers are antialiased
		});
		let dataLayers = [];


		const findMissingElements = (array1, array2, key) => {
			// Create a Set of unique keys from array2
			const keysSet = new Set(array2.map(item => item[key]));

			// Filter elements from array1 that are not in keysSet
			const missingElements = array1.filter(item => !keysSet.has(item[key]));

			return missingElements;
		}

		const getLayerInView = (ne, sw) => {
			const ne_lat = ne.lat;
			const ne_lng = sw.lng;
			const sw_lat = sw.lat;
			const sw_lng = ne.lng;
			let dataLayersInView = datas.reduce((oldData, item) => {
				let item_lng = item.coordinates[0];
				let item_lat = item.coordinates[1];

				if (ne_lng > sw_lng) {
					if (item_lng > sw_lng && item_lng < ne_lng && item_lat > sw_lat && item_lat < ne_lat) {
						oldData.push(item);
					}
				} else {
					if (item_lng < sw_lng && item_lng > ne_lng && item_lat > sw_lat && item_lat < ne_lat) {
						oldData.push(item);
					}
				}
				return oldData;
			}, [])

			dataLayersInView = findMissingElements(dataLayersInView, dataLayers, 'id');
			dataLayers.push(...dataLayersInView);
			return dataLayersInView;
		}

		//use the MapLibre GL JS map canvas for three.js
		let renderer = new THREE.WebGLRenderer({
			canvas: map.getCanvas(),
			antialias: true
		});

		const addLayer = (object) => {
			let scene, camera, stats;
			let model, skeleton, mixer, clock, animations;
			console.log(object.id)
			camera = new THREE.Camera();
			scene = new THREE.Scene();
			// parameters to ensure the model is georeferenced correctly on the map
			const modelOrigin = object.coordinates;
			const modelAltitude = 0;
			const modelRotate = [Math.PI / 2, 0, 0];

			const modelAsMercatorCoordinate = maplibregl.MercatorCoordinate.fromLngLat(
				modelOrigin,
				modelAltitude
			);

			// transformation parameters to position, rotate and scale the 3D model onto the map
			const modelTransform = {
				translateX: modelAsMercatorCoordinate.x,
				translateY: modelAsMercatorCoordinate.y,
				translateZ: modelAsMercatorCoordinate.z,
				rotateX: modelRotate[0],
				rotateY: modelRotate[1],
				rotateZ: modelRotate[2],
				/* Since our 3D model is in real world meters, a scale transform needs to be
				* applied since the CustomLayerInterface expects units in MercatorCoordinates.
				*/
				scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits()
			};

			const dirLight = new THREE.DirectionalLight(0xffffff, inten);
			let d = 1000;
			let r = 2;
			let mapSize = 8192;
			dirLight.position.set(0, 700, 100);
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = mapSize;
			dirLight.shadow.mapSize.height = mapSize;
			dirLight.shadow.camera.top = dirLight.shadow.camera.right = d;
			dirLight.shadow.camera.bottom = dirLight.shadow.camera.left = -d;
			dirLight.shadow.camera.near = 1;
			dirLight.shadow.camera.far = 400000;
			dirLight.shadow.camera.visible = true;
			scene.add(dirLight);
			// configuration of the custom layer for a 3D model per the CustomLayerInterface
			const customLayer = {
				id: object.id,
				type: 'custom',
				renderingMode: '3d',
				onAdd(map, gl) {
					// use the three.js GLTF loader to add the 3D model to the three.js scene
					const loader = new GLTFLoader();
					loader.load(
						object.scenegraph,
						(gltf) => {
							let glsence = gltf.scene;
							glsence.traverse(function (model) {
								if (model.isMesh) {
									model.castShadow = true;
								}
							});
							glsence.castShadow = true;
							glsence.scale.set(3.64, 3.3, 3.3);
							glsence.rotation.set(0, 1.376, 0);
							scene.add(glsence);
							const s = new THREE.Box3().setFromObject(glsence).getSize(new THREE.Vector3(0, 0, 0));
							const sizes = [s.x, s.y, s.z];
							const planeSize = Math.max(...sizes) * 10;
							const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
							const planeMat = new THREE.ShadowMaterial();
							planeMat.opacity = 0.5;
							let plane = new THREE.Mesh(planeGeo, planeMat);
							plane.rotateX(-Math.PI / 2);
							plane.receiveShadow = true;
							scene.add(plane);
						}
					);
					renderer.autoClear = false;
					renderer.shadowMap.enabled = true;
					// renderer.shadowMap.autoUpdate = false;
					// renderer.shadowMap.needsUpdate= true;
				},
				render(gl, matrix) {
					function animateSun() {
						const date = new Date(); // Current date and time
						const latitude = 21.0285; // Latitude of Hanoi
						const longitude = 105.8542; // Longitude of Hanoi
						const sunPosition = SunCalc.getPosition(date, latitude, longitude);

						// Convert Sun's Azimuth and Altitude to Three.js coordinates
						const azimuth = -sunPosition.azimuth + Math.PI; // Inverse azimuth for Three.js
						const altitude = sunPosition.altitude;

						// Convert azimuth and altitude to directional light position
						const lightDistance = 1000; // Distance of light from the scene origin
						const lightPosition = new THREE.Vector3(
							lightDistance * Math.cos(altitude) * Math.sin(azimuth),
							lightDistance * Math.sin(altitude),
							lightDistance * Math.cos(altitude) * Math.cos(azimuth)
						);

						// Normalize altitude to be between 0 and 1 (assuming sun is above horizon)
						const normalizedAltitude = Math.max(0, Math.min(1, altitude / (Math.PI / 2)));

						// Set light intensity based on normalized altitude
						const minIntensity = 0.1; // Minimum intensity during nighttime
						const maxIntensity = 5.0; // Maximum intensity during daytime
						const lightIntensity = minIntensity + (maxIntensity - minIntensity) * normalizedAltitude
						// Set up directional light

						dirLight.position.copy(lightPosition);
						dirLight.intensity = lightIntensity;
						requestAnimationFrame(animateSun);
					}

					const rotationX = new THREE.Matrix4().makeRotationAxis(
						new THREE.Vector3(1, 0, 0),
						modelTransform.rotateX
					);
					const rotationY = new THREE.Matrix4().makeRotationAxis(
						new THREE.Vector3(0, 1, 0),
						modelTransform.rotateY
					);
					const rotationZ = new THREE.Matrix4().makeRotationAxis(
						new THREE.Vector3(0, 0, 1),
						modelTransform.rotateZ
					);

					const m = new THREE.Matrix4().fromArray(matrix);
					const l = new THREE.Matrix4()
						.makeTranslation(
							modelTransform.translateX,
							modelTransform.translateY,
							modelTransform.translateZ
						)
						.scale(
							new THREE.Vector3(
								modelTransform.scale,
								-modelTransform.scale,
								modelTransform.scale
							)
						)
						.multiply(rotationX)
						.multiply(rotationY)
						.multiply(rotationZ);

					camera.projectionMatrix = m.multiply(l);
					renderer.resetState();
					renderer.render(scene, camera);
					animateSun()
					map.triggerRepaint();
				}
			};
			map.addLayer(customLayer);
		}

		let isNight = false;
		map.on('load', function () {
			const initialViewport = getWebViewport();
			const dataLayersInView = getLayerInView(initialViewport._ne, initialViewport._sw);
			dataLayersInView.forEach((item) => addLayer(item));
			var btnChangeMode = document.getElementById('change-day-night-btn');
			if (btnChangeMode) {
				btnChangeMode.addEventListener('click', function () {
					if (isNight) {
						inten = 3;
						map.setStyle('https://api.maptiler.com/maps/basic/style.json?key=0LV4DUQC2Ud6fTkmgGJf', { diff: false }),
							isNight = false
					} else {

						inten = 0.5;
						map.setStyle('https://api.maptiler.com/maps/basic-v2-dark/style.json?key=0LV4DUQC2Ud6fTkmgGJf', { diff: false }),
							isNight = true;
					}
				})

			}
		})

		map.on('style.load', function () {
			console.log("tyle.load")
			dataLayers = [];
			const initialViewport = getWebViewport();
			const dataLayersInView = getLayerInView(initialViewport._ne, initialViewport._sw);
			dataLayersInView.forEach((item) => addLayer(item));
		});

		map.on('click', (e) => {
			// const coordinates = e.features[0].geometry.coordinates.slice();
			console.log('coordinates', e)
		});

		// Function to get the web viewport with center coordinates
		function getWebViewport() {
			// Get the current geographical bounds of the map
			var bounds = map.getBounds();
			return bounds;
		}



		// Event listener for the 'dragend' event
		map.on('dragend', function () {
			const viewport = getWebViewport();
			const dataLayersInView = getLayerInView(viewport._ne, viewport._sw);
			dataLayersInView.forEach((item) => addLayer(item));
		});

	</script>
</body>

</html>